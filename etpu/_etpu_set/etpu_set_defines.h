// This file is auto-generated by the ASH WARE ETEC Linker.
// It contains useful information for host-CPU side driver code
//    !!!   DO NOT EDIT THIS FILE   !!!
// Copyright (C) 2015 ASH WARE, Inc.

#ifndef __etpu_set_defines_H
#define __etpu_set_defines_H

// Register ECR, field ETB, byte address, Each Engine
// ECR.ETB = (_ENTRY_TABLE_BASE_ADDR_)>>11;
#define _ENTRY_TABLE_BASE_ADDR_                  0x00

// Starting DATA RAM address where the block copy of initialized data begins
// memcpy( ETPU_DATA_RAM_START+_GLOBAL_INIT_DATA_ADDR_, &_global_mem_init[0], _GLOBAL_DATA_SIZE_);
#define _GLOBAL_INIT_DATA_ADDR_                  0x00

// Register MISCCMPR - ETPU MISC Compare Register
// MISCCMPR = _MISC_VALUE_;
#define _MISC_VALUE_                             0x6F8B6640

// SCM Off Opcode - opcode returned when in the weeds
// SCMOFFDATAR = _SCM_OFF_OPCODE_;
#define _SCM_OFF_OPCODE_                         0xFFD06607

// exported autodef macros from user "#pragma export_autodef_macro" commands
#define FS_ETPU_SPI_MASTER_INIT_TCR1_HSR  7
#define FS_ETPU_SPI_MASTER_INIT_TCR2_HSR  5
#define FS_ETPU_SPI_MASTER_RUN_HSR  3
#define FS_ETPU_SPI_MASTER_CPHA_0_FM0  0
#define FS_ETPU_SPI_MASTER_CPHA_1_FM0  1
#define FS_ETPU_SPI_MASTER_SHIFT_DIR_MSB_FM1  0
#define FS_ETPU_SPI_MASTER_SHIFT_DIR_LSB_FM1  1
#define FS_ETPU_SPI_MASTER_MAX_SLAVE_SELECT_CNT  4
#define FS_ETPU_SPI_SLAVE_INIT_HSR  1
#define FS_ETPU_SPI_SLAVE_INIT_SS_HSR  2
#define FS_ETPU_SPI_SLAVE_SET_DATA_HSR  7
#define FS_ETPU_SPI_SLAVE_CPHA_0_FM0  0
#define FS_ETPU_SPI_SLAVE_CPHA_1_FM0  1
#define FS_ETPU_SPI_SLAVE_SHIFT_DIR_MSB_FM1  0
#define FS_ETPU_SPI_SLAVE_SHIFT_DIR_LSB_FM1  1

// exported autodef text from user "#pragma export_autodef_text" commands
// none specified

// 32-bit Global Variable address
// address = SPRAM + _GLOB_VAR32__Global_error_data_
#define _GLOB_VAR32__Global_error_data_          0x00

// Global Variable type information
// Can be used in conjunction with other auto-define information to simplify interfaces
#define _GLOB_VAR_TYPE__Global_error_data_       T_sint32

// Global Variable/Data Size (not including scratchpad)
// address (end) = SPRAM + _GLOBAL_VAR_SIZE_
#define _GLOBAL_VAR_SIZE_                        0x04

// Global Scratchpad Base Address in bytes
// address (start) = SPRAM + _GLOBAL_SCRATCHPAD_BASE_ADDR_
#define _GLOBAL_SCRATCHPAD_BASE_ADDR_            0x04

// Global Scratchpad Data Size in bytes
// address (end) = SPRAM + _GLOBAL_VAR_SIZE_ + _GLOBAL_SCRATCHPAD_SIZE_
#define _GLOBAL_SCRATCHPAD_SIZE_                 0x00

// Total Global Data Size (starts at address 0, includes any global scratchpad allocation)
// address (end) = SPRAM + _GLOBAL_DATA_SIZE_
#define _GLOBAL_DATA_SIZE_                       0x04

// User Engine Variable/Data Size (not including scratchpad)
// address (end) = ((ECR_X.ERBA)<<9) + _ENGINE_VAR_SIZE_
#define _ENGINE_VAR_SIZE_                        0x00

// Engine Scratchpad Data Size in bytes
// address (end) = ((ECR_X.ERBA)<<9) + _ENGINE_VAR_SIZE_ + _ENGINE_SCRATCHPAD_SIZE_
#define _ENGINE_SCRATCHPAD_SIZE_                 0x00

// Total Engine Data Size (starts at engine address 0, includes any engine scratchpad allocation)
// address (end) = ((ECR_X.ERBA)<<9) + _ENGINE_DATA_SIZE_
#define _ENGINE_DATA_SIZE_                       0x00

// Amount of DATA RAM (in bytes) required for the stack
// (ideally, programs require none)
// #define CHANNEL_FRAME_START (((_GLOBAL_DATA_SIZE_ + _STACK_SIZE_) + 7) & ~7)
#define _STACK_SIZE_                             0x00

// Default channel frame base address definitions
// One for the single eTPU case, one for the dual eTPU case
#define _CHANNEL_FRAME_1ETPU_BASE_ADDR  0x8
#define _CHANNEL_FRAME_2ETPU_BASE_ADDR  0x8

#if 0
// This section gives an example of how stack bases should
// be initialized for each new channel frame (replace FUNC1, etc.
// with actual function names) in a simulator script file.  Host
// code should use the same mechanism.  The conditional initialization
// is done because a channel frame will not have a stack base allocated
// if it is not needed.
#ifdef _CPBA24_FUNC1___STACKBASE_
write_chan_data24(FUNC1_CHAN1, _CPBA24_FUNC1___STACKBASE_, _ETPU_A_STACK_BASE_ADDR);
#endif // _CPBA24_FUNC1___STACKBASE_
#ifdef _CPBA24_FUNC2___STACKBASE_
write_chan_data24(FUNC2_CHAN1, _CPBA24_FUNC2___STACKBASE_, _ETPU_B_STACK_BASE_ADDR);
write_chan_data24(FUNC2_CHAN2, _CPBA24_FUNC2___STACKBASE_, _ETPU_B_STACK_BASE_ADDR);
write_chan_data24(FUNC2_CHAN3, _CPBA24_FUNC2___STACKBASE_, _ETPU_B_STACK_BASE_ADDR);
write_chan_data24(FUNC2_CHAN4, _CPBA24_FUNC2___STACKBASE_, _ETPU_B_STACK_BASE_ADDR);
#endif // _CPBA24_FUNC2___STACKBASE_
// continue on through all channels for both eTPUs...
#endif // 0

//============================================================================
//==========     SPI_slave

// Register CXCR, field CFS, Function Number, Each Channel
// CXCR.CFS = _FUNCTION_NUM_SPI_slave_;
#define _FUNCTION_NUM_SPI_slave_                 0x01

// Register CXCR, field ETCS, Type (Alternate or Standard), Each Channel
// CXCR.ETCS = _ENTRY_TABLE_TYPE_SPI_slave_;
#define _ENTRY_TABLE_TYPE_SPI_slave_             0x01

// Register CXCR, field ETPD, Pin Direction (Input or Output), Each Channel
// CXCR.ETPD = _ENTRY_TABLE_PIN_DIR_SPI_slave_;
#define _ENTRY_TABLE_PIN_DIR_SPI_slave_          0x00

// 8-bit Channel Variable address offsets
// address = ((CXCR.CPBA)<<3) + _CPBA8_SPI_slave__use_TCR1_
#define _CPBA8_SPI_slave__use_TCR1_              0x00
#define _CPBA8_BOOLBITOFFSET_SPI_slave__use_TCR1_ 0x07
#define _CPBA8_SPI_slave__CPOL_                  0x00
#define _CPBA8_BOOLBITOFFSET_SPI_slave__CPOL_    0x06
#define _CPBA8_SPI_slave__bit_count_             0x04
#define _CPBA8_SPI_slave__MISO_chan_             0x08
#define _CPBA8_SPI_slave__selected_flag_         0x0C

// 24-bit Channel Variable address offsets
// address = ((CXCR.CPBA)<<3) + _CPBA24_SPI_slave__data_out_reg_
#define _CPBA24_SPI_slave__data_out_reg_         0x01
#define _CPBA24_SPI_slave__data_in_reg_          0x05
#define _CPBA24_SPI_slave__timeout_              0x09

// Channel Variable type information
// Can be used in conjunction with other auto-define information to simplify interfaces
#define _CPBA_TYPE_SPI_slave__use_TCR1_          T_bool
#define _CPBA_TYPE_SPI_slave__CPOL_              T_bool
#define _CPBA_TYPE_SPI_slave__bit_count_         T_sint8
#define _CPBA_TYPE_SPI_slave__data_out_reg_      T_uint24
#define _CPBA_TYPE_SPI_slave__data_in_reg_       T_uint24
#define _CPBA_TYPE_SPI_slave__timeout_           T_sint24
#define _CPBA_TYPE_SPI_slave__MISO_chan_         T_sint8
#define _CPBA_TYPE_SPI_slave__selected_flag_     T_sint8

// Channel Frame Size, amount of RAM required for each channel
// CXCR.CPBA (this) = CXCR.CPBA (last) + _FRAME_SIZE_SPI_slave_;
#define _FRAME_SIZE_SPI_slave_                   0x18

//============================================================================
//==========     SPI_master

// Register CXCR, field CFS, Function Number, Each Channel
// CXCR.CFS = _FUNCTION_NUM_SPI_master_;
#define _FUNCTION_NUM_SPI_master_                0x00

// Register CXCR, field ETCS, Type (Alternate or Standard), Each Channel
// CXCR.ETCS = _ENTRY_TABLE_TYPE_SPI_master_;
#define _ENTRY_TABLE_TYPE_SPI_master_            0x01

// Register CXCR, field ETPD, Pin Direction (Input or Output), Each Channel
// CXCR.ETPD = _ENTRY_TABLE_PIN_DIR_SPI_master_;
#define _ENTRY_TABLE_PIN_DIR_SPI_master_         0x01

// 8-bit Channel Variable address offsets
// address = ((CXCR.CPBA)<<3) + _CPBA8_SPI_master__CPOL_
#define _CPBA8_SPI_master__CPOL_                 0x00
#define _CPBA8_BOOLBITOFFSET_SPI_master__CPOL_   0x07
#define _CPBA8_SPI_master__bit_count_            0x04
#define _CPBA8_SPI_master__slave_select_chan_    0x08

// 24-bit Channel Variable address offsets
// address = ((CXCR.CPBA)<<3) + _CPBA24_SPI_master__half_period_
#define _CPBA24_SPI_master__half_period_         0x01
#define _CPBA24_SPI_master__data_out_reg_        0x05
#define _CPBA24_SPI_master__data_in_reg_         0x09
#define _CPBA24_SPI_master__slave_select_delay_  0x11

// Channel Array Variable address offsets
// address = ((CXCR.CPBA)<<3) + _CPBA_ARRAY_SPI_master__slave_select_chan_list_
#define _CPBA_ARRAY_SPI_master__slave_select_chan_list_ 0x0C
#define _CPBA_TYPE_ARRAY_SPI_master__slave_select_chan_list_ T_uint8
#define _CPBA_ARRAY_SPI_master__slave_select_chan_list_DIM_1_LENGTH_ 0x04
#define _CPBA_ARRAY_SPI_master__slave_select_chan_list_DIM_1_STRIDE_ 0x01

// Channel Variable type information
// Can be used in conjunction with other auto-define information to simplify interfaces
#define _CPBA_TYPE_SPI_master__half_period_      T_sint24
#define _CPBA_TYPE_SPI_master__CPOL_             T_bool
#define _CPBA_TYPE_SPI_master__bit_count_        T_sint8
#define _CPBA_TYPE_SPI_master__data_out_reg_     T_uint24
#define _CPBA_TYPE_SPI_master__data_in_reg_      T_uint24
#define _CPBA_TYPE_SPI_master__slave_select_chan_list_ T_array
#define _CPBA_TYPE_SPI_master__slave_select_chan_ T_uint8
#define _CPBA_TYPE_SPI_master__slave_select_delay_ T_sint24

// Channel Frame Size, amount of RAM required for each channel
// CXCR.CPBA (this) = CXCR.CPBA (last) + _FRAME_SIZE_SPI_master_;
#define _FRAME_SIZE_SPI_master_                  0x20

#endif // __etpu_set_defines_H
